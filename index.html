<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>THREE JS RAIN</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>

    <script id="vertex-shader" type="x-shader/x-fragment">
        "#define GLSLIFY 1
attribute vec2 uv2;

varying vec4 vMirrorCoord;
varying vec2 vUv;
varying vec2 vUv2;
varying vec3 vWorldPosition;

uniform mat4 uTextureMatrix;

void main () {
	vec3 transformedPosition = position;

	vUv = uv;
	vUv2 = uv2;

	vWorldPosition = (modelMatrix * vec4(position, 1.)).xyz;

	vMirrorCoord = uTextureMatrix * vec4( transformedPosition, 1.0 );

	vec4 mvPosition = vec4( transformedPosition, 1.0 );
	mvPosition = modelViewMatrix * mvPosition;

	gl_Position = projectionMatrix * mvPosition;
}"
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #define GLSLIFY 1
            float blendSoftLight(float base, float blend) {
                return (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));
            }

            vec3 blendSoftLight(vec3 base, vec3 blend) {
                return vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));
            }

            vec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {
                return (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));
            }

            float blendLinearDodge(float base, float blend) {
                // Note : Same implementation as BlendAddf
                return min(base+blend,1.0);
            }

            vec3 blendLinearDodge(vec3 base, vec3 blend) {
                // Note : Same implementation as BlendAdd
                return min(base+blend,vec3(1.0));
            }

            vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                return (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));
            }

            float blendLinearBurn(float base, float blend) {
                // Note : Same implementation as BlendSubtractf
                return max(base+blend-1.0,0.0);
            }

            vec3 blendLinearBurn(vec3 base, vec3 blend) {
                // Note : Same implementation as BlendSubtract
                return max(base+blend-vec3(1.0),vec3(0.0));
            }

            vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {
                return (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));
            }

            float blendLinearLight(float base, float blend) {
                return blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));
            }

            vec3 blendLinearLight(vec3 base, vec3 blend) {
                return vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));
            }

            vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                return (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));
            }

            varying vec4 vMirrorCoord;
            varying vec2 vUv;
            varying vec2 vUv2;
            varying vec3 vWorldPosition;

            uniform sampler2D uRoughnessTexture;
            uniform sampler2D uNormalTexture;
            uniform sampler2D uOpacityTexture;
            uniform vec2 uTexScale;
            uniform sampler2D uTexture;
            uniform vec2 uMipmapTextureSize;
            uniform float uDistortionAmount;
            uniform float uBlurStrength;
            uniform float uTime;
            uniform float uRainCount;

            vec4 cubic(float v) {
                vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;
                vec4 s = n * n * n;
                float x = s.x;
                float y = s.y - 4.0 * s.x;
                float z = s.z - 4.0 * s.y + 6.0 * s.x;
                float w = 6.0 - x - y - z;
                return vec4(x, y, z, w);
            }

            // https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl
            vec4 textureBicubic(sampler2D t, vec2 texCoords, vec2 textureSize) {
                vec2 invTexSize = 1.0 / textureSize;
                texCoords = texCoords * textureSize - 0.5;

                vec2 fxy = fract(texCoords);
                texCoords -= fxy;
                vec4 xcubic = cubic(fxy.x);
                vec4 ycubic = cubic(fxy.y);

                vec4 c = texCoords.xxyy + vec2(-0.5, 1.5).xyxy;

                vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);
                vec4 offset = c + vec4(xcubic.yw, ycubic.yw) / s;

                offset *= invTexSize.xxyy;

                vec4 sample0 = texture2D(t, offset.xz);
                vec4 sample1 = texture2D(t, offset.yz);
                vec4 sample2 = texture2D(t, offset.xw);
                vec4 sample3 = texture2D(t, offset.yw);

                float sx = s.x / (s.x + s.y);
                float sy = s.z / (s.z + s.w);

                return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);
            }

            // With original size argument
            vec4 packedTexture2DLOD(sampler2D tex, vec2 uv, int level, vec2 originalPixelSize) {
                float floatLevel = float(level);
                vec2 atlasSize;
                atlasSize.x = floor(originalPixelSize.x * 1.5);
                atlasSize.y = originalPixelSize.y;

                // we stop making mip maps when one dimension == 1

                float maxLevel = min(floor(log2(originalPixelSize.x)), floor(log2(originalPixelSize.y)));
                floatLevel = min(floatLevel, maxLevel);

                // use inverse pow of 2 to simulate right bit shift operator

                vec2 currentPixelDimensions = floor(originalPixelSize / pow(2.0, floatLevel));
                vec2 pixelOffset = vec2(floatLevel > 0.0 ? originalPixelSize.x : 0.0, floatLevel > 0.0 ? currentPixelDimensions.y : 0.0);

                // "minPixel / atlasSize" samples the top left piece of the first pixel
                // "maxPixel / atlasSize" samples the bottom right piece of the last pixel
                vec2 minPixel = pixelOffset;
                vec2 maxPixel = pixelOffset + currentPixelDimensions;
                vec2 samplePoint = mix(minPixel, maxPixel, uv);
                samplePoint /= atlasSize;
                vec2 halfPixelSize = 1.0 / (2.0 * atlasSize);
                samplePoint = min(samplePoint, maxPixel / atlasSize - halfPixelSize);
                samplePoint = max(samplePoint, minPixel / atlasSize + halfPixelSize);
                return textureBicubic(tex, samplePoint, originalPixelSize);
            }

            vec4 packedTexture2DLOD(sampler2D tex, vec2 uv, float level, vec2 originalPixelSize) {
                float ratio = mod(level, 1.0);
                int minLevel = int(floor(level));
                int maxLevel = int(ceil(level));
                vec4 minValue = packedTexture2DLOD(tex, uv, minLevel, originalPixelSize);
                vec4 maxValue = packedTexture2DLOD(tex, uv, maxLevel, originalPixelSize);
                return mix(minValue, maxValue, ratio);
            }

            // Rain drop shader from https://www.shadertoy.com/view/ldfyzl Ctrl-Alt-Test (http://www.ctrl-alt-test.fr)
            // Maximum number of cells a ripple can cross.
            #define MAX_RADIUS 1

            // Hash functions shamefully stolen from:
            // https://www.shadertoy.com/view/4djSRW
            #define HASHSCALE1 .1031
            #define HASHSCALE3 vec3(.1031, .1030, .0973)

            float hash12(vec2 p) {
                vec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);
                p3 += dot(p3, p3.yzx + 19.19);
                return fract((p3.x + p3.y) * p3.z);
            }

            vec2 hash22(vec2 p) {
                vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);
                p3 += dot(p3, p3.yzx + 19.19);
                return fract((p3.xx + p3.yz) * p3.zy);

            }

            float map(float value, float min1, float max1, float min2, float max2) {
                return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
            }

            void main() {
                vec2 texUv = vUv * uTexScale;
                float floorOpacity = texture2D(uOpacityTexture, texUv).r;
                vec3 floorNormal = texture2D(uNormalTexture, texUv).rgb * 2. - 1.;
                floorNormal = normalize(floorNormal);
                float roughness = texture2D(uRoughnessTexture, texUv).r;

                vec2 reflectionUv = vMirrorCoord.xy / vMirrorCoord.w;

                vec2 rippleUv = 75. * vUv * uTexScale;

                vec2 p0 = floor(rippleUv);

                float rainStrength = map(uRainCount, 0., 10000., 3., 0.5);
                if(rainStrength == 3.) {
                    rainStrength = 50.;
                }

                vec2 circles = vec2(0.);
                for(int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j) {
                    for(int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i) {
                        vec2 pi = p0 + vec2(i, j);
                        vec2 hsh = pi;
                        vec2 p = pi + hash22(hsh);

                        float t = fract(0.8 * uTime + hash12(hsh));
                        vec2 v = p - rippleUv;
                        float d = length(v) - (float(MAX_RADIUS) + 1.) * t + (rainStrength * 0.1 * t);

                        float h = 1e-3;
                        float d1 = d - h;
                        float d2 = d + h;
                        float p1 = sin(31. * d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);
                        float p2 = sin(31. * d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);
                        circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * pow(1. - t, rainStrength));
                    }
                }
                circles /= float((MAX_RADIUS * 2 + 1) * (MAX_RADIUS * 2 + 1));

                float intensity = 0.05 * floorOpacity;
                vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));

                vec3 color = packedTexture2DLOD(uTexture, reflectionUv + floorNormal.xy * uDistortionAmount - intensity * n.xy, roughness * uBlurStrength, uMipmapTextureSize).rgb;

                gl_FragColor = vec4(color, 1.0);
            }
    </script>
    <script type="module" src="/main.js"></script>

</body>
</html>